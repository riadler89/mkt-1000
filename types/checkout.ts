// Generated by dts-bundle-generator v9.5.1

/* eslint-disable */

type EventListener$1<T, K extends keyof T> = (payload: T[K]) => void
export type AddEventListenerMethod<T> = <K extends keyof T>(
  event: K,
  handler: EventListener$1<T, K>,
) => void
export type RemoveEventListenerMethod<T> = <K extends keyof T>(
  event: K,
  handler: EventListener$1<T, K>,
) => void
export type EmitMethod<T> = <K extends keyof T>(event: K, payload: T[K]) => void
export type EventBus<T> = {
  listen: AddEventListenerMethod<T>
  remove: RemoveEventListenerMethod<T>
  emit: EmitMethod<T>
}
declare const predefinedFormats: Record<string, RegExp>
declare const steps: readonly ['auth', 'shipping', 'payment']
export type AbTest = {
  experimentId: string
  percentage: number
  conditions?: {
    customerGroup?: string[]
  }
}
export type AddressForm = {
  specialComponent?: boolean
  title: BasicFeature
  googleMapsAutocomplete: BasicFeature
  streetHouseNumber: {
    separateFields: boolean
    houseNumber: {
      position: 'first' | 'second'
    } & Validation
    street: Validation
  } & Validation
  additional: BasicFeature & Validation
  zipCodeCity: {
    zipCode: BasicFeature & {
      position: 'first' | 'second'
    } & Validation & {
        allowList?: boolean
        blockList?: boolean
        completion: BasicFeature & {
          disableSpecialComponentSuggestion?: boolean
        }
        formatOnBlur?: SubstitutionOptions
      }
    city: Validation & {
      completion: BasicFeature
    }
  }
  state: BasicFeature &
    Validation & {
      select: BasicFeature & {
        blockList?: string[]
      }
    }
}
export type AppQualifier = {
  environment?: string
  shop: string
  country: Country
  locale: Locale
  appId?: number
  shopId?: number
  apiHost: string
  origin: Origin
  useCheckoutNext?: boolean
  legacyApiHost?: string
  useAuthComponent?: boolean
}
export type AyCheckout = {
  appQualifier?: AppQualifier
  abTesting?: AbTest
  customer?: {
    firstName: string
    lastName: string
    email: string
  }
  initialBackendConfig?: Record<string, any>
  startTimer?: number
}
export type BasicFeature = {
  enabled: boolean
}
export type BirthDateValidation = {
  required?: boolean
  minAge?: number
}
export type CheckboxConfig = TextsConfig & {
  required?: boolean
  initialValue?: boolean
}
export type Condition = Partial<
  Record<ConditionField, string[]> & {
    minBasketTotal?: number
  }
>
export type ConditionField =
  | 'carrierGroupKey'
  | 'shippingOptionKey'
  | 'collectionPointType'
  | 'paymentOptionKey'
  | 'shippingCountry'
  | 'billingCountry'
  | 'minBasketTotal'
export type Conditions = {
  enabled?: Condition
  required?: Condition
}
export type Config = AppQualifier & {
  header: {
    desktopHeight: number
    mobileHeight: number
  }
  transactionId: string
  statePollInterval: number
  paymentConfirmationPollTimeout: number
  features: {
    breadcrumbs: BasicFeature
    ingrid: BasicFeature
    expressCheckout: {
      payPal: BasicFeature & NotImplemented
      applePay: BasicFeature & NotImplemented
      amazonPay: BasicFeature & NotImplemented
    }
    customerNumberSignIn: BasicFeature & Validation
    passwordVisibilityToggle: BasicFeature
    secondEmailField: BasicFeature
    thirdPartySignIn: BasicFeature & {
      disableFirstPartySignIn: boolean
      providers: Provider[]
    }
    guestCheckout: BasicFeature
    fullCountryNames: BasicFeature
    fullWidthScrollNavigation: BasicFeature
    neutralGender: BasicFeature
    notSpecifiedGender: BasicFeature
    addressBook: BasicFeature
    discountCodes: {
      position: 'basket' | 'payment'
      alwaysShowOnReviewPage?: boolean
    }
    vouchers: BasicFeature &
      Validation & {
        disableInitialVoucherNotification: boolean
      }
    giftCards: BasicFeature &
      Validation & {
        pin: BasicFeature & Validation
      }
    loyaltyProgram: BasicFeature &
      Validation & {
        type: string
        disableRemoval: boolean
        icon: BasicFeature
        toolTip: BasicFeature
        formatOnBlur?: SubstitutionOptions
        redeemablePoints: BasicFeature
        registration: BasicFeature & {
          disableForGuest: boolean
        }
      }
    lowestPriorPrice: BasicFeature
    shippingCostToolTip: BasicFeature
    dutiesAndTaxes: BasicFeature
    sentry: BasicFeature
    datadog: BasicFeature & {
      sessionSampleRate: number
      forwardErrorsToLogs: boolean
    }
    appDeepLinkRewrites: BasicFeature
    review: {
      showAlways: boolean
    }
  }
  currency: Currency
  formats: {
    date: string
    currency: 'symbol' | 'code' | 'name' | 'narrowSymbol'
    hideCurrencyDecimals: boolean
  }
  names: {
    firstName: Validation
    lastName: {
      position: 'first' | 'second'
    } & Validation
  }
  emailPassword: {
    email: Pick<Validation, 'layeredValidation'>
    password: Validation
  }
  tracking: {
    sendPlaintextEmail: boolean
    sendDataLayerEvents: boolean
    sendFormFieldErrors: boolean
  }
  basket: {
    position: 'bottom' | 'top'
    showSoldOutItems: boolean
    hideBrands: boolean
    hideOnAuthStep: boolean
    hideItemRemovalButton: boolean
    disableQuantityChange: boolean
    hasDisabledLinks: boolean
    imageParameters: string | null
    showNetPrices?: boolean
    showCollapsiblePromotion: boolean
    showMerchantInformation: boolean
    replaceFreeItemPriceWithText: boolean
  }
  deliveryOptions: {
    preferred: 'homeDelivery' | 'collectionPoint' | 'storePickup'
    suggestCollectionPoint: BasicFeature
    forwardToCollectionPoint: BasicFeature
  }
  carrierOptions: {
    position: 'shippingTop' | 'shippingBottom' | 'payment'
    suggestCollectionPoint: BasicFeature
    isCollapsible: BasicFeature
  }
  collectionPoints: {
    defaultMaximumDistance: number
    maximumDistanceOptions: number[]
    googleMapsAutocomplete: BasicFeature
    preferredView: 'map' | 'list'
  }
  shippingOptions: {
    descriptions: OptionDescriptions
    hideDeliveryEstimation: boolean
  }
  paymentOptions: {
    paymentBrandsList: {
      paymentOptionKey: PaymentOptionKey
      icons: PaymentIcons[]
    }[]
    descriptions: OptionDescriptions
    hidePaymentIcons: boolean
  }
  addressForms: Record<Country, AddressForm>
  dynamicFields: Partial<Record<DynamicFieldAreaKey, DynamicFields>>
  links: Link[]
  notifications: ConfigNotification[]
  customizedAssets: string[]
  externalAssets: Record<string, string>
  styles: Record<string, string>
  isProduction: boolean
  availableCountries: {
    shipping: {
      iso2Code: Country
      centerCoordinates: Coordinates
    }[]
    billing?: {
      iso2Code: Country
    }[]
  }
  session: Session
  translations: Record<string, any>
  expressTranslations: Record<string, any>
  urls: {
    passwordResetConfirmation: string
  }
  abTests: AbTest[]
  version: string
}
export type ConfigNotification = {
  textTranslationKey: string
  startDateTime?: string
  endDateTime?: string
  steps?: Step[]
  type?: NotificationLevel
}
export type Coordinates = {
  latitude: number
  longitude: number
}
/**
 * ISO 3166-1 alpha-2 country code (e.g. DE, FR, BE)
 */
export type Country = string
/**
 * ISO 4217 currency code (e.g. EUR, USD, SAR)
 */
export type Currency = string
export type DynamicFieldAreaKey =
  | 'register'
  | 'guest'
  | 'shippingAddress'
  | 'collectionPoint'
  | 'billingAddress'
  | 'paymentOptions'
  | 'payment'
  | 'paymentBelowMobileBasket'
  | 'review'
export type DynamicFields = {
  taxId?: BasicFeature &
    Validation & {
      conditions?: Conditions
    }
  birthDate?: BasicFeature &
    BirthDateValidation & {
      conditions?: Conditions
    }
  phoneNumber?: BasicFeature &
    PhoneNumberValidation & {
      conditions?: Conditions
    }
  logisticsPhoneNumber?: BasicFeature &
    PhoneNumberValidation & {
      conditions?: Conditions
    }
  carrierCustomerId?: BasicFeature &
    Validation & {
      conditions?: Conditions
    }
  checkboxes?: CheckboxConfig[]
  texts?: TextsConfig[]
}
export type IDP = {
  driver: string
  key: string
  redirectUrl: string
}
export type LayeredValidation = {
  format: string
  translationKey: string
}
export type Link = {
  key: string
  link: string
}
/**
 * Locale with underscore (e.g. de_DE, en_US, nl_BE)
 */
export type Locale = string
export type NotImplemented = Record<string, never>
export type NotificationLevel = 'success' | 'info' | 'warning' | 'error'
export type OptionDescriptions = {
  short: boolean
  toolTip: boolean
}
export type Origin = 'web' | 'app'
export type PaymentIcons =
  | 'afterPay'
  | 'amazonPay'
  | 'amex'
  | 'apple'
  | 'applePay'
  | 'bancaires'
  | 'bancontact'
  | 'blik'
  | 'cod'
  | 'creditCard'
  | 'dinersClub'
  | 'discover'
  | 'giropay'
  | 'google'
  | 'googlePay'
  | 'iDeal'
  | 'invoice'
  | 'isracard'
  | 'jcb'
  | 'klarna'
  | 'maestro'
  | 'mastercard'
  | 'mbway'
  | 'mobilePay'
  | 'ob'
  | 'p24'
  | 'payPal'
  | 'payU'
  | 'postFinance'
  | 'ratepay'
  | 'ratepayInvoiceDe'
  | 'ratepayInvoiceEn'
  | 'ratepayInvoiceFr'
  | 'ratepayInvoiceNl'
  | 'riverty'
  | 'sepa'
  | 'sepaDirectDebit'
  | 'twint'
  | 'twisto'
  | 'unionPay'
  | 'unzerInvoice'
  | 'visa'
export type PaymentOptionKey =
  | 'standard_cheque'
  | 'standard_creditcard'
  | 'standard_invoice'
  | 'standard_pay_in_advance'
  | 'standard_cod'
  | 'bg_cod'
  | 'cy_cod'
  | 'cz_cod'
  | 'dhl_cod'
  | 'ee_cod'
  | 'es_cod'
  | 'gr_cod'
  | 'hr_cod'
  | 'hu_cod'
  | 'it_cod'
  | 'lt_cod'
  | 'lv_cod'
  | 'pl_cod'
  | 'pt_cod'
  | 'ro_cod'
  | 'sa_cod'
  | 'si_cod'
  | 'sk_cod'
  | 'accounting'
  | 'adyen_apple_pay'
  | 'adyen_creditcard'
  | 'adyen_google_pay'
  | 'adyen_ideal'
  | 'adyen_klarna_paynow'
  | 'adyen_klarna_paylater'
  | 'adyen_klarna_installments'
  | 'adyen_mbway'
  | 'adyen_mobilepay'
  | 'adyen_paypal'
  | 'adyen_online_banking_pl'
  | 'adyen_twint'
  | 'afterpay_invoice'
  | 'amazon_pay'
  | 'arvato_creditcard'
  | 'arvato_p24'
  | 'arvato_paypal'
  | 'arvato_ideal'
  | 'computop_applepay'
  | 'computop_bancontact'
  | 'computop_creditcard'
  | 'computop_creditcard_mastercard'
  | 'computop_creditcard_visa'
  | 'computop_googlepay'
  | 'computop_maestro'
  | 'computop_paydirekt'
  | 'computop_payu'
  | 'computop_payu_cee'
  | 'computop_payu_twisto'
  | 'computop_postfinance'
  | 'klarna_paylater'
  | 'klarna_paynow_direct_debit'
  | 'klarna_paynow_direct_bank_transfer'
  | 'klarna_installments'
  | 'klarna_paynow'
  | 'paypal'
  | 'paypal_instant'
  | 'ratepay_directdebit'
  | 'ratepay_invoice'
  | 'saferpay_bancontact'
  | 'saferpay_creditcard_maestro'
  | 'saferpay_creditcard_mastercard'
  | 'saferpay_creditcard_visa'
  | 'saferpay_ideal'
  | 'saferpay_p24'
  | 'saferpay_twint'
  | 'spay_adyen_apple_pay'
  | 'spay_adyen_blik'
  | 'spay_adyen_credit_card'
  | 'spay_adyen_creditcard_bc'
  | 'spay_adyen_google_pay'
  | 'spay_adyen_ideal'
  | 'spay_adyen_mobilepay'
  | 'spay_adyen_online_banking_pl'
  | 'spay_adyen_twint'
  | 'spay_klarna_paynow'
  | 'spay_paypal'
  | 'spay_klarna_paylater'
  | 'spay_klarna_payovertime'
  | 'unzer_creditcard'
  | 'witt_cod'
  | 'witt_deferred_invoice'
  | 'witt_invoice'
  | 'witt_pay_instalments'
export type PhoneNumberValidation = {
  required?: boolean
  restrictCountry?: boolean
  mobileOnly?: boolean
}
export type Provider = {
  key: string
  color?: string
}
export type Session = {
  jwtSecret: string
  token?: string
  accessToken?: string
  correlationId?: string
  altLoyaltyId?: string
}
export type Step = (typeof steps)[number]
export type SubstitutionOptions = {
  input: string
  output: string
}
export type TextsConfig = {
  name: string
  i18nKeys: {
    label: string
    headline?: string
  }
  conditions?: Conditions
}
export type Validation = {
  required?: boolean
  minLength?: number
  maxLength?: number
  format?: RegExp | keyof typeof predefinedFormats | string
  illegalTerms?: string[]
  layeredValidation?: LayeredValidation[]
}
declare enum Events {
  GET_TRANSLATIONS_SUCCESS = 'getTranslations:success',
  GET_TRANSLATIONS_ERROR = 'getTranslations:error',
  GET_CONFIG_SUCCESS = 'getConfig:success',
  GET_CONFIG_ERROR = 'getConfig:error',
}
declare namespace InternalRequests {
  type GetTranslations = {
    shopId: string
  }
  type GetConfig = {
    session?: Session
    transactionId?: string
    jsonConfig?: string
  }
}
declare namespace InternalResponses {
  type GetTranslations = object
  type GetConfig = object
}
export type InternalEndpoints = {
  getTranslations: {
    request: InternalRequests.GetTranslations
    response: InternalResponses.GetTranslations
  }
  getConfig: {
    request: InternalRequests.GetConfig
    response: InternalResponses.GetConfig
  }
}
export type InternalEventPayloads = {
  [Events.GET_TRANSLATIONS_SUCCESS]: any
  [Events.GET_TRANSLATIONS_ERROR]: any
  [Events.GET_CONFIG_SUCCESS]: any
  [Events.GET_CONFIG_ERROR]: any
}
declare const createInternal: (
  appQualifier: AppQualifier,
  emit: EmitMethod<EventPayloads>,
) => {
  getConfig: ({
    session,
    transactionId,
    jsonConfig,
  }: InternalEndpoints['getConfig']['request']) => Promise<Config>
}
export type Internal = ReturnType<typeof createInternal>
export type AccessTokenPayload = {
  accessToken: string
}
export type AuthCodePayload = {
  authCode: string
}
export declare enum AuthErrorKey {
  INVALID_TOKEN = 'INVALID_TOKEN',
  USER_NOT_FOUND = 'USER_NOT_FOUND',
  USER_DEACTIVATED = 'USER_DEACTIVATED',
  PASSWORD_RESET_HASH_EXPIRED = 'PASSWORD_RESET_HASH_EXPIRED',
  USER_ALREADY_EXISTS = 'USER_ALREADY_EXISTS',
  TOO_MANY_ATTEMPTS = 'TOO_MANY_ATTEMPTS',
  API_EXCEPTION = 'API_EXCEPTION',
}
export type AuthErrorPayload =
  | never
  | undefined
  | {
      errors: Record<string, string>
      message: string
    }
  | {
      errorKey?: AuthErrorKey
      retryAfterSeconds?: number
      message?: string
    }
export type Gender = 'm' | 'f' | 'd' | 'n'
export type AuthSuccessPayload =
  | {
      accessToken: string
      refreshToken: string
    }
  | {
      authCode: string
    }
export type AuthRequests = {
  Login: {
    email: string
    password: string
    grantType?: string
    clientId?: number
  }
  LoginGuest: {
    firstName: string
    lastName: string
    email: string
    gender: Gender
  }
  Register: {
    email: string
    password: string
    gender: string
    firstName: string
    lastName: string
    birthDate?: string
    phone?: string
    subscriptionText?: string
    title?: string
    type?: 'personal' | 'retail' | 'organization' | 'family'
    hasSubscribedNewsletter?: boolean
    address?: {
      billing: {
        additional?: string
        city: string
        countryCode?: string
        firstName: string
        forwardToCollectionPoint?: boolean
        gender: Gender
        state?: string
        streetHouseNumber: string
        title?: string
        zipCode?: string
      }
    }
  }
  Logout: never
  GenerateToken:
    | {
        refreshToken: string
      }
    | {
        authorizationCode: string
      }
  SendResetEmail: {
    email: string
  }
  UpdateByHash: {
    password: string
    hash: string
  }
  getIdentityProviders: never
}
export type AuthResponses = {
  Login: AuthSuccessPayload | AuthErrorPayload
  LoginGuest: AuthSuccessPayload | AuthErrorPayload
  Register: AuthSuccessPayload | AuthErrorPayload
  Logout: never
  GenerateToken: {
    accessToken: string
    refreshToken: string
    git: any
  }
  SendResetEmail: never
  UpdateByHash: {
    accessToken: string
  }
  getIdentityProviders: {
    driver: string
    key: string
    redirectUrl: string
  }[]
}
export type AuthEndpoints = {
  login: {
    request: AuthRequests['Login']
    response: AuthResponses['Login']
  }
  loginGuest: {
    request: AuthRequests['LoginGuest']
    response: AuthResponses['LoginGuest']
  }
  register: {
    request: AuthRequests['Register']
    response: AuthResponses['Register']
  }
  logout: {
    request: AuthRequests['Logout']
    response: AuthResponses['Logout']
  }
  generateToken: {
    request: AuthRequests['GenerateToken']
    response: AuthResponses['GenerateToken']
  }
  sendResetEmail: {
    request: AuthRequests['SendResetEmail']
    response: AuthResponses['SendResetEmail']
  }
  updateByHash: {
    request: AuthRequests['UpdateByHash']
    response: AuthResponses['UpdateByHash']
  }
  getIdentityProviders: {
    request: AuthRequests['getIdentityProviders']
    response: AuthResponses['getIdentityProviders']
  }
}
export type ExchangeAuthCodeHook = (params: { authCode: string }) => Promise<{
  accessToken: string
}>
export type RefreshTokenHook = (
  params:
    | {
        accessToken: string
      }
    | {
        authorizationCode: string
      },
) => Promise<{
  accessToken: string
}>
declare const createAuth: (
  { apiHost, shopId, appId }: AppQualifier,
  emit: EmitMethod<EventPayloads>,
) => {
  init: (params?: {
    clientId: number
    accessToken?: string
    hooks: {
      exchangeAuthCodeHook: ExchangeAuthCodeHook
      refreshTokenHook: RefreshTokenHook
    }
  }) => Promise<boolean>
  refreshToken: (code?: string) => Promise<
    | {
        accessToken: string
        refreshToken: string
        git: any
      }
    | {
        accessToken: string
      }
  >
  getAccessToken: () => string | null
  setAccessToken: (accessToken: string) => void
  login: (
    body: {
      email: string
      password: string
    },
    headers?: Record<string, string>,
  ) => Promise<AccessTokenPayload | AuthCodePayload | AuthErrorPayload>
  loginGuest: (
    body: {
      firstName: string
      lastName: string
      email: string
      gender: Gender
    },
    headers?: Record<string, string>,
  ) => Promise<AccessTokenPayload | AuthCodePayload | AuthErrorPayload>
  register: (
    body: AuthRequests['Register'],
    headers?: Record<string, string>,
  ) => Promise<
    | {
        accessToken: string
        refreshToken: string
      }
    | {
        accessToken: string
        refreshToken: null
      }
  >
  updateByHash: (body: AuthEndpoints['updateByHash']['request']) => Promise<
    | {
        accessToken: string
        refreshToken: string
      }
    | {
        accessToken: string
        refreshToken: null
      }
  >
  sendResetEmail: (
    body: AuthEndpoints['sendResetEmail']['request'],
  ) => Promise<never>
  logout: () => Promise<any>
  geIdentitiesProviders: (
    authUrlParameters?: Record<string, any>,
  ) => Promise<IDP[]>
}
export type Auth = ReturnType<typeof createAuth>
export type DeviceType = 'app' | 'desktop' | 'mobile'
declare const createExpress: ({ apiHost, shopId, appId }: AppQualifier) => {
  preload: (device: DeviceType) => Promise<void>
}
export type Express = ReturnType<typeof createExpress>
declare enum AUTH_FLOW_SOURCES {
  INIT = 'init',
  LOGIN = 'login',
  GUEST = 'login-guest',
  REGISTER = 'register',
  NEW_PASSWORD = 'new-password',
}
declare enum AuthEvents {
  AUTH_SUCCESS = 'auth:success',
  AUTH_ERROR = 'auth:error',
  AUTH_LOGOUT = 'auth:logout',
  TOKEN_REFRESH_SUCCESS = 'token:refresh:success',
  TOKEN_REFRESH_ERROR = 'token:refresh:error',
  TOKEN_EXPIRED = 'token:expired',
}
export type AuthEventsPayloads = {
  [AuthEvents.AUTH_SUCCESS]: {
    accessToken?: string
    source: AUTH_FLOW_SOURCES
  }
  [AuthEvents.AUTH_ERROR]: {
    source: AUTH_FLOW_SOURCES
    error: AuthErrorPayload
  }
  [AuthEvents.AUTH_LOGOUT]: unknown
  [AuthEvents.TOKEN_REFRESH_SUCCESS]: {
    accessToken: string
  }
  [AuthEvents.TOKEN_REFRESH_ERROR]: AuthErrorPayload
  [AuthEvents.TOKEN_EXPIRED]: unknown
}
export type EventPayloads = AuthEventsPayloads & InternalEventPayloads
export type Scayle = {
  express: {
    V3: Express
  }
  auth: {
    V3: Auth & {
      events: Omit<EventBus<EventPayloads>, 'emit'>
    }
  }
  internal: {
    V3: Internal & {
      events: Omit<EventBus<EventPayloads>, 'emit'>
    }
  }
}
declare global {
  interface Window {
    ayCheckout: AyCheckout
    scayle: Scayle
  }

  interface WindowEventMap {
    'scayle.auth.ready': void
    'scayle.checkout.ready': void
    'scayle.express.ready': void
  }
}

export {}
